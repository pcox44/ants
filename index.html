<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ants on a Polygon — Smooth Animation</title>
<style>
:root{
  --bg:#0f172a;--card:#0b1220;--accent:#7dd3fc;--muted:#94a3b8;
}
body{font-family:Inter,ui-sans-serif,system-ui,Arial,Helvetica;background:var(--bg);color:#e6eef8;margin:0;padding:24px;}
.container{max-width:980px;margin:0 auto}
h1{margin:0 0 12px;font-size:20px}
.controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:14px}
input[type=number]{width:90px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#051125;color:inherit}
button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#022;cursor:pointer;font-weight:600}
button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
.card{background:var(--card);padding:14px;border-radius:12px;margin-bottom:12px}
#canvasWrap{display:flex;gap:12px;align-items:flex-start}
canvas{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:10px}
.results{min-width:260px}
.stat{font-size:14px;margin:6px 0}
.progress{height:10px;background:rgba(255,255,255,0.03);border-radius:6px;overflow:hidden}
.progress > i{display:block;height:100%;background:linear-gradient(90deg,#7dd3fc,#60a5fa);width:0%}
.small{font-size:12px;color:var(--muted)}
.footer{margin-top:10px;color:#cbd5e1;font-size:13px;line-height:1.4}
.footer p strong{color:#7dd3fc;}
.footer div{text-align:center;}
.history{margin-top:8px;max-height:160px;overflow:auto;border-radius:8px;padding:8px;background:rgba(0,0,0,0.25)}
table{width:100%;border-collapse:collapse}
th,td{padding:6px;text-align:left;font-size:13px}
th{color:var(--muted);font-weight:600}

#histogram{width:100%;height:240px;margin-top:20px;border-radius:10px;}
</style>

<!-- MathJax -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div class="container">
<h1>Ants on a Polygon — Smooth Animation</h1>

<div class="card controls">
<label class="small">Number of sides (n): <input id="nSides" type="number" min="3" value="5"></label>
<label class="small">Starting vertex A: <input id="startA" type="number" min="0" value="0"></label>
<label class="small">Place B opposite? <input id="autoOpp" type="checkbox" checked></label>
<button id="btn1">Run ×1</button>
<button id="btn10">Run ×10</button>
<button id="btn50">Run ×50</button>
<button id="btn1000">Run ×1000</button>
<button id="animate" class="secondary">Animate single sim</button>
<button id="reset" class="secondary">Reset</button>
<label class="small">Histogram cutoff: <input id="cutoff" type="number" min="1" value="50"></label>
</div>

<div class="card" id="canvasWrap">
<canvas id="polyCanvas" width="580" height="340"></canvas>

<div class="results">
<div class="stat"><strong>Last run:</strong> <span id="lastRun">—</span></div>
<div class="stat"><strong>Mean rounds:</strong> <span id="mean">—</span></div>
<div class="stat"><strong>Median:</strong> <span id="median">—</span></div>
<div class="stat"><strong>Min / Max:</strong> <span id="minmax">—</span></div>
<div class="stat"><strong>Total sims:</strong> <span id="total">0</span></div>
<div class="stat small">Progress:</div>
<div class="progress"><i id="progressBar"></i></div>

<div class="history" id="history">
<table><thead><tr><th>#</th><th>Rounds</th></tr></thead><tbody id="histBody"></tbody></table>
</div>
</div>
</div>

<canvas id="histogram"></canvas>




<script>
/* -------------------- Utility -------------------- */
const $ = id => document.getElementById(id);
const canvas = $('polyCanvas');
const ctx = canvas.getContext('2d');
const histCanvas = $('histogram');
const hctx = histCanvas.getContext('2d');

let cumulativeResults = [];

function mod(a,m){return ((a % m)+m)%m;}
function oppositeIndex(n,a){return n%2===0? mod(a+n/2,n):mod(a+Math.floor(n/2),n);}

function runOne(n,a,b){
  let rounds=0;
  while(true){
    rounds++;

    const aMove = Math.random()<0.5?1:-1;
    const bMove = Math.random()<0.5?1:-1;

    const newA = mod(a+aMove,n);
    const newB = mod(b+bMove,n);

    // Meet if same vertex or crossed
    if(newA===newB || (newA===b && newB===a)) return rounds;

    a=newA; b=newB;
  }
}

function mean(a){return a.reduce((s,x)=>s+x,0)/a.length;}
function median(a){
  const s=[...a].sort((x,y)=>x-y);
  const m=Math.floor(s.length/2);
  return s.length%2? s[m] : (s[m-1]+s[m])/2;
}

/* -------------------- Drawing -------------------- */
function drawPolygon(n,a,b,antsPos){
  const W=canvas.width,H=canvas.height;
  ctx.clearRect(0,0,W,H);

  const cx=W/2, cy=H/2, R=Math.min(W,H)/2-40;
  const verts=[];

  for(let i=0;i<n;i++){
    const θ=-Math.PI/2 + i*(2*Math.PI/n);
    verts.push([cx+R*Math.cos(θ), cy+R*Math.sin(θ)]);
  }

  // Edges
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const [x,y]=verts[i];
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.closePath();
  ctx.strokeStyle='rgba(125,211,252,0.55)';
  ctx.lineWidth=2;
  ctx.stroke();

  // Vertices
  for(let i=0;i<n;i++){
    const [x,y]=verts[i];
    ctx.beginPath();
    ctx.arc(x,y,5,0,Math.PI*2);
    ctx.fillStyle='rgba(255,255,255,0.25)';
    ctx.fill();
  }

  if(!antsPos) return;

  const interp=(p,q,t)=>[p[0]+(q[0]-p[0])*t, p[1]+(q[1]-p[1])*t];

  function drawAnt(color, triple){
    const [vStart, vEnd, prog] = triple;
    const pos = interp(verts[vStart], verts[vEnd], prog);
    ctx.beginPath();
    ctx.arc(pos[0],pos[1],8,0,Math.PI*2);
    ctx.fillStyle=color;
    ctx.fill();
  }

  drawAnt('red', antsPos[0]);
  drawAnt('lime', antsPos[1]);
}

/* -------------------- Histogram -------------------- */
function drawHistogram(data) {
  const cutoff = parseInt($('cutoff').value) || 50;

  // Make the histogram canvas automatically a bit wider
  const parentW = histCanvas.parentElement.clientWidth;
  const W = histCanvas.width = Math.max(760, parentW - 20);
  const H = histCanvas.height = 260;

  hctx.clearRect(0, 0, W, H);
  if (!data.length) return;

  const bins = 20;
  const binWidth = cutoff / bins;

  // Count frequencies normally and ignore overflow
  const freq = new Array(bins).fill(0);

  for (const v of data) {
    if (v <= cutoff) {
      const idx = Math.min(bins - 1, Math.floor(v / binWidth));
      freq[idx]++;
    }
  }

  const total = data.length;
  const proportions = freq.map(f => f / total);
  const maxProp = Math.max(...proportions);

  const leftPadding = 55;  // space for y-axis labels
  const bottomPadding = 35;
  const topPadding = 25;

  const usableHeight = H - bottomPadding - topPadding;
  const usableWidth = W - leftPadding - 10;

  // --- Background grid ---
  hctx.strokeStyle = 'rgba(255,255,255,0.10)';
  hctx.lineWidth = 1.5;
  for (let p = 0; p <= 1; p += 0.25) {
    const y = topPadding + usableHeight * (1 - p);
    hctx.beginPath();
    hctx.moveTo(leftPadding, y);
    hctx.lineTo(W - 10, y);
    hctx.stroke();

    // y-axis label
    hctx.fillStyle = 'rgba(255,255,255,0.75)';
    hctx.font = '11px sans-serif';
    hctx.textAlign = 'right';
    hctx.fillText(p.toFixed(2), leftPadding - 8, y + 3);
  }

  // --- Neon gradient for bars ---
  const gradient = hctx.createLinearGradient(leftPadding, 0, W, 0);
  gradient.addColorStop(0.0, '#00eaff');
  gradient.addColorStop(0.5, '#7b5bff');
  gradient.addColorStop(1.0, '#ff00e0');

  const barWidth = usableWidth / bins - 5;

  // --- Draw bars ---
  for (let i = 0; i < bins; i++) {
    const p = proportions[i];
    const barH = (p / maxProp) * usableHeight;
    const x = leftPadding + i * (usableWidth / bins) + 2;
    const y = topPadding + usableHeight - barH;

    hctx.fillStyle = gradient;

    // Rounded rectangle bars
    const r = 6;
    hctx.beginPath();
    hctx.moveTo(x + r, y);
    hctx.lineTo(x + barWidth - r, y);
    hctx.quadraticCurveTo(x + barWidth, y, x + barWidth, y + r);
    hctx.lineTo(x + barWidth, y + barH - r);
    hctx.quadraticCurveTo(x + barWidth, y + barH, x + barWidth - r, y + barH);
    hctx.lineTo(x + r, y + barH);
    hctx.quadraticCurveTo(x, y + barH, x, y + barH - r);
    hctx.lineTo(x, y + r);
    hctx.quadraticCurveTo(x, y, x + r, y);
    hctx.fill();
  }

  // --- X-axis ticks and labels ---
  hctx.fillStyle = 'rgba(255,255,255,0.85)';
  hctx.font = '11px sans-serif';
  hctx.textAlign = 'center';

  for (let i = 0; i <= bins; i += 2) {
    const x = leftPadding + (usableWidth * (i / bins));
    const value = Math.round(i * binWidth);
    hctx.fillText(value, x, H - 10);
  }

  // --- Axis labels ---
  // X-axis: Rounds
  hctx.fillStyle = 'rgba(255,255,255,0.9)';
  hctx.font = '13px sans-serif';
  hctx.textAlign = 'center';
  hctx.fillText("Rounds", leftPadding + usableWidth / 2, H - 5);

  // Y-axis: Proportion
  hctx.save();
  hctx.translate(18, H / 2);
  hctx.rotate(-Math.PI / 2);
  hctx.fillText("Proportion", 0, 0);
  hctx.restore();

  // --- Title ---
  hctx.fillStyle = '#7dd3ff';
  hctx.font = '17px sans-serif';
  hctx.textAlign = 'center';
  hctx.shadowColor = '#00eaff';
  hctx.shadowBlur = 15;
  hctx.fillText("Rounds Distribution", W / 2, 18);
  hctx.shadowBlur = 0;
}


/* -------------------- Stats Panel -------------------- */
function updateStats(results){
  $('lastRun').textContent = results.at(-1) ?? '—';
  $('mean').textContent = results.length ? mean(results).toFixed(3) : '—';
  $('median').textContent = results.length ? median(results).toFixed(3) : '—';
  $('minmax').textContent = results.length ? `${Math.min(...results)} / ${Math.max(...results)}` : '—';
  $('total').textContent = results.length;

  const tbody=$('histBody');
  tbody.innerHTML='';
  const start=Math.max(0, results.length-200);

  for(let i=start;i<results.length;i++){
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${i+1}</td><td>${results[i]}</td>`;
    tbody.appendChild(tr);
  }

  drawHistogram(results);
}

/* -------------------- Animation -------------------- */
async function animateSim(){
  const n = parseInt($('nSides').value)||5;
  const startA = parseInt($('startA').value)||0;
  const startB = $('autoOpp').checked ? oppositeIndex(n,startA) : startA;

  let a=startA, b=startB;
  let rounds=0;

  drawPolygon(n,a,b,[[a,a,1],[b,b,1]]);

  while(true){
    rounds++;

    const aMove = Math.random()<0.5?1:-1;
    const bMove = Math.random()<0.5?1:-1;

    const newA = mod(a+aMove,n);
    const newB = mod(b+bMove,n);

    // Interpolate
    const steps=20;
    for(let s=1;s<=steps;s++){
      drawPolygon(n,a,b,[
        [a,newA,s/steps],
        [b,newB,s/steps]
      ]);
      await new Promise(r=>requestAnimationFrame(r));
    }

    // Meeting?
    if(newA===newB || (newA===b && newB===a)){
      cumulativeResults.push(rounds);
      updateStats(cumulativeResults);
      return;
    }

    a=newA; b=newB;
  }
}

/* -------------------- UI -------------------- */
$('btn1').onclick=()=>{
  const n=parseInt($('nSides').value),a=parseInt($('startA').value),
  b=$('autoOpp').checked?oppositeIndex(n,a):a;
  cumulativeResults.push(runOne(n,a,b));
  updateStats(cumulativeResults);
};

$('btn10').onclick=()=>{
  const n=parseInt($('nSides').value),a=parseInt($('startA').value),
  b=$('autoOpp').checked?oppositeIndex(n,a):a;
  for(let i=0;i<10;i++) cumulativeResults.push(runOne(n,a,b));
  updateStats(cumulativeResults);
};

$('btn50').onclick=()=>{
  const n=parseInt($('nSides').value),a=parseInt($('startA').value),
  b=$('autoOpp').checked?oppositeIndex(n,a):a;
  for(let i=0;i<50;i++) cumulativeResults.push(runOne(n,a,b));
  updateStats(cumulativeResults);
};

$('btn1000').onclick=()=>{
  const n=parseInt($('nSides').value),a=parseInt($('startA').value),
  b=$('autoOpp').checked?oppositeIndex(n,a):a;
  for(let i=0;i<1000;i++) cumulativeResults.push(runOne(n,a,b));
  updateStats(cumulativeResults);
};

$('animate').onclick=animateSim;

$('reset').onclick=()=>{
  cumulativeResults=[];
  updateStats(cumulativeResults);
  init();
};

$('nSides').addEventListener('change',()=>{cumulativeResults=[];updateStats([]);init();});

/* -------------------- Initialization -------------------- */
function init(){
  const n=parseInt($('nSides').value)||5;
  const a=parseInt($('startA').value)||0;
  const b=$('autoOpp').checked?oppositeIndex(n,a):a;
  drawPolygon(n,a,b);
}

window.addEventListener('resize',()=>{
  canvas.width = Math.min(700,Math.max(420,Math.floor(window.innerWidth*0.55)));
  canvas.height=340;
  init();
});

canvas.width=Math.min(700,Math.max(420,Math.floor(window.innerWidth*0.55)));
canvas.height=340;
init();

</script>
</body>
</html>
