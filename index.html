<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ants on a Polygon Simulation</title>
<style>
  body {
    background-color: #111;
    color: white;
    font-family: sans-serif;
    text-align: center;
    margin: 0;
    padding: 0;
  }
  canvas {
    background-color: #222;
    display: block;
    margin: 20px auto;
    border-radius: 10px;
  }
  #controls {
    margin: 10px;
  }
  button, input {
    margin: 5px;
    padding: 5px 10px;
    font-size: 16px;
    border-radius: 5px;
    border: none;
  }
  #desc {
    margin: 20px auto;
    max-width: 800px;
    text-align: left;
  }
</style>
</head>
<body>

<h1>Ants on a Polygon Simulation</h1>

<div id="controls">
  <label>Number of sides: <input type="number" id="numSides" value="6" min="3"></label>
  <button id="resetBtn">Reset</button>
  <button onclick="singleSim()">Single Sim</button>
  <button onclick="runSims(10)">10 Sims</button>
  <button onclick="runSims(50)">50 Sims</button>
  <button onclick="runSims(1000)">1000 Sims</button>
  <label>Histogram cutoff: <input type="number" id="cutoff" value="50" min="1"></label>
</div>

<canvas id="polygonCanvas" width="600" height="600"></canvas>
<canvas id="histCanvas" width="800" height="200"></canvas>

<div id="desc">
  <p id="theory">Theoretical mean: -</p>
</div>

<script>
const canvas = document.getElementById("polygonCanvas");
const ctx = canvas.getContext("2d");
const histCanvas = document.getElementById("histCanvas");
const hctx = histCanvas.getContext("2d");

let numSides = 6;
let results = [];
let animating = false;

// reset
document.getElementById("resetBtn").addEventListener("click", () => {
  numSides = parseInt(document.getElementById("numSides").value);
  results = [];
  drawPolygon();
  drawHistogram();
  updateTheory();
});

document.getElementById("numSides").addEventListener("change", () => {
  numSides = parseInt(document.getElementById("numSides").value);
  results = [];
  drawPolygon();
  drawHistogram();
  updateTheory();
});

// draw polygon and ants
function drawPolygon(ant1=-1, ant2=-1) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const cx = canvas.width/2;
  const cy = canvas.height/2;
  const r = canvas.width/2 - 50;
  const verts = [];
  for(let i=0;i<numSides;i++){
    const angle = 2*Math.PI*i/numSides - Math.PI/2;
    verts.push({x: cx + r*Math.cos(angle), y: cy + r*Math.sin(angle)});
  }
  // edges
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<numSides;i++){
    const next = (i+1)%numSides;
    ctx.moveTo(verts[i].x, verts[i].y);
    ctx.lineTo(verts[next].x, verts[next].y);
  }
  ctx.stroke();
  // vertices
  ctx.fillStyle = "white";
  for(let v of verts){
    ctx.beginPath();
    ctx.arc(v.x,v.y,5,0,2*Math.PI);
    ctx.fill();
  }
  // ants
  if(ant1>=0 && ant2>=0){
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(verts[ant1].x, verts[ant1].y, 10,0,2*Math.PI);
    ctx.fill();
    ctx.fillStyle = "green";
    ctx.beginPath();
    ctx.arc(verts[ant2].x, verts[ant2].y, 10,0,2*Math.PI);
    ctx.fill();
  }
}

// single animated simulation
function singleSim(){
  if(animating) return;
  animating = true;
  let ant1 = 0;
  let ant2 = Math.floor(numSides/2);
  drawPolygon(ant1, ant2);
  const interval = setInterval(()=>{
    ant1 = (ant1 + (Math.random()<0.5?1:-1)+numSides)%numSides;
    ant2 = (ant2 + (Math.random()<0.5?1:-1)+numSides)%numSides;
    drawPolygon(ant1, ant2);
    let d = Math.min((ant2-ant1+numSides)%numSides,(ant1-ant2+numSides)%numSides);
    if(d<=1){
      clearInterval(interval);
      animating=false;
      results.push(null); // no numerical result, just visualize
    }
  },200);
}

// run multiple simulations
function runSims(count){
  const cutoff = parseInt(document.getElementById("cutoff").value);
  results = [];
  let completed = 0;
  function simStep(){
    let ant1=0;
    let ant2=Math.floor(numSides/2);
    let rounds=0;
    while(true){
      rounds++;
      ant1 = (ant1 + (Math.random()<0.5?1:-1)+numSides)%numSides;
      ant2 = (ant2 + (Math.random()<0.5?1:-1)+numSides)%numSides;
      let d = Math.min((ant2-ant1+numSides)%numSides,(ant1-ant2+numSides)%numSides);
      if(d<=1) break;
      if(rounds>10000) break; // safety cutoff
    }
    results.push(rounds);
    completed++;
    if(completed<count){
      setTimeout(simStep,0);
    }else{
      drawHistogram();
      updateTheory();
    }
  }
  simStep();
}

// histogram
function drawHistogram(){
  hctx.clearRect(0,0,histCanvas.width,histCanvas.height);
  if(results.length===0) return;
  const cutoff = parseInt(document.getElementById("cutoff").value);
  const hist = Array(cutoff+1).fill(0);
  for(let r of results){
    if(r<=cutoff) hist[r]++;
  }
  const maxH = Math.max(...hist);
  const w = histCanvas.width/(cutoff+1);
  for(let i=0;i<hist.length;i++){
    const h = hist[i]/maxH*histCanvas.height;
    hctx.fillStyle = "cyan";
    hctx.fillRect(i*w,histCanvas.height-h,w-1,h);
  }
}

// theoretical mean
function updateTheory(){
  const theoryEl = document.getElementById("theory");
  if(numSides%2===0){
    // simple approximation for even n (distance=n/2)
    const d = numSides/2;
    const mean = Math.pow(d,2)/2; // rough for crossing rule
    theoryEl.innerHTML = `Theoretical mean (approx): ${mean.toFixed(2)} rounds`;
  }else{
    theoryEl.innerHTML = `Theoretical mean: use simulation for odd polygons`;
  }
}

// initial draw
drawPolygon();
drawHistogram();
updateTheory();
</script>

</body>
</html>
